# Weighted Voronoi Stippling

This repository contains a high-performance CPU implementation of the Weighted Voronoi Stippling algorithm (Secord 2002) for converting grayscale images into artistic stipple representations.

## Example output

**Original example photo (1024 x 1024 px):**

![Original photo of a boy](/images/example-1024px.png)

**Voronoi stippling of the photo with 10 000 stipples:**

![Voronoi stippling of the photo](/images/example-1024px_10000.png)

**Visualization of the tour created by an external Lin-Kernihan TSP Solver:**

![Visualization of the tour](/images/example-1024px_1000v.png)

## Features

The implementation uses Numba JIT compilation to achieve excellent performance on CPU:

### 1. Numba JIT Compilation
- **Rejection Sampling**: ~10-50x speedup using `@jit(nopython=True, parallel=True)`
- **Voronoi Computation**: Custom implementation with parallel loops for optimal CPU utilization
- **Centroid Computation**: Batch processing all centroids in parallel
- **Pure Python Fallback**: Automatic fallback to pure Python if Numba is unavailable

### 2. Algorithmic Improvements
- **Batch Processing**: Compute all centroids simultaneously instead of one-by-one
- **Memory Optimization**: Avoid creating individual masks for each point
- **Efficient Data Structures**: Use contiguous arrays for better cache performance
- **Parallel Processing**: Leverage all CPU cores through Numba's parallel execution

### 3. Output Formats
- **PNG Images**: Visual representation of stipples as black dots on white background
- **TSP Files**: Standard TSPLIB format for traveling salesman optimization

## Installation

Install the required dependencies:

```bash
pip install -r requirements.txt
```

### Dependencies

The project requires:
- **NumPy**: For numerical computations
- **Numba**: For JIT compilation and parallel processing
- **Pillow (PIL)**: For image I/O operations

All dependencies are automatically installed from `requirements.txt`.

## Usage

### 1. Generate Stipples (Required First Step)

The `stippling.py` script converts images into stipple representations and generates both PNG images and TSP coordinate files:

```bash
# Basic usage with default settings
python stippling.py images/example-512px.png

# Specify number of stipples and iterations
python stippling.py images/example-512px.png --stipples 5000 --iter 30

# Control stipple size and output location
python stippling.py images/example-512px.png --stipples 2000 --radius 2.0 --iter 20
```

**Output files:**
- `stipplings/png/example-512px_5000.png` - Visual stipple image
- `stipplings/tsp/example-512px_5000.tsp` - Coordinate data for TSP optimization

### 2. Visualize Results

The `visualize.py` script provides multiple ways to visualize stipple points and TSP tours:

#### Points-Only Visualization
```bash
# Show only stipple points
python visualize.py stipplings/tsp/example-512px_5000.tsp --points-only
python visualize.py stipplings/tsp/example-512px_5000.tsp --points-only --point-size 2.0
```

#### Tour Visualization (Requires .tour file)
**⚠️ Important:** To visualize tour lines, you need a `.tour` file generated by an external TSP solver.

```bash
# Show only tour lines (requires .tour file from TSP solver)
python visualize.py stipplings/tsp/example-512px_5000.tsp \
    --tour-path tour_solution.tour --lines-only

# Show tour lines with points highlighted
python visualize.py stipplings/tsp/example-512px_5000.tsp \
    --tour-path tour_solution.tour --show-points
```

### 3. TSP Solver Integration (Optional but Recommended)

To generate optimized drawing paths for plotters or artistic applications, you'll need to solve the Traveling Salesman Problem using the generated `.tsp` files.

#### Option A: Using Concorde TSP Solver (Recommended)
```bash
# Install Concorde (varies by system)
# Ubuntu/Debian: sudo apt-get install concorde-tsp
# macOS: brew install concorde

# Solve TSP to get optimal tour
concorde stipplings/tsp/example-512px_5000.tsp

# This creates: example-512px_5000.sol (solution file)
# Convert to .tour format if needed
```

#### Option B: Using Lin-Kernighan Heuristic (Fast approximation)
```bash
# If you have Concorde package, it includes linkern
linkern stipplings/tsp/example-512px_5000.tsp

# This creates: example-512px_5000.tour (tour file)
```

#### Option C: Using Online TSP Solvers
1. Upload your `.tsp` file to online solvers like:
   - [NEOS Server](https://neos-server.org/neos/)
   - [TSP solver websites](http://www.math.uwaterloo.ca/tsp/concorde.html)
2. Download the solution and convert to `.tour` format

#### Option D: Generate Simple Tours with tsp_utils.py
```bash
# Generate a simple nearest-neighbor tour (not optimal, but quick)
python tsp_utils.py stipplings/tsp/example-512px_5000.tsp --nearest-neighbor
```

### 4. Complete Workflow Example

```bash
# Step 1: Generate stipples from image
python stippling.py images/photo.jpg --stipples 10000 --iter 30
# Creates: stipplings/png/photo_10000.png, stipplings/tsp/photo_10000.tsp

# Step 2: Solve TSP (choose one method)
linkern stipplings/tsp/photo_10000.tsp                    # Fast heuristic
# OR
concorde stipplings/tsp/photo_10000.tsp                   # Optimal solution

# Step 3: Move tour file to visualization directory
mv photo_10000.tour visualizations/tour/

# Step 4: Visualize the optimized tour
python visualize.py stipplings/tsp/photo_10000.tsp \
    --tour-path visualizations/tour/photo_10000.tour \
    --output visualizations/png/photo_optimized_tour.png

# Step 5: Generate different visualizations
python visualize.py stipplings/tsp/photo_10000.tsp --points-only \
    --output visualizations/png/photo_points_only.png

python visualize.py stipplings/tsp/photo_10000.tsp \
    --tour-path visualizations/tour/photo_10000.tour --lines-only \
    --line-color blue --output visualizations/png/photo_tour_lines.png
```

### Performance Options

```bash
# Disable Numba JIT compilation (use pure Python fallback)
python stippling.py images/example-512px.png --no-numba

# Enable verbose logging
python stippling.py images/example-512px.png --verbose
```

### Command Line Options

#### stippling.py
- `image`: Path to input image file (PNG, JPEG, BMP, TIFF, etc.)
- `--output`: Base name for output files (default: derived from input filename)
- `--stipples`: Number of stipples to generate (default: 5000, range: 1-1,000,000)
- `--radius`: Radius of each stipple in pixels (default: 1.0, range: 0.1-100)
- `--iter`: Number of Lloyd relaxation iterations (default: 30, range: 1-1000)
- `--no-numba`: Disable Numba JIT compilation (use pure Python fallback)
- `--verbose`: Enable detailed progress logging

#### visualize.py
- `tsp_path`: Path to TSP file containing coordinates (positional argument)
- `--tour-path`: Path to tour file containing TSP solution (optional)
- `--output`: Save plot to file instead of displaying
- `--points-only`: Visualize only points without tour lines
- `--lines-only`: Visualize only tour lines without points
- `--show-points`: Show points on top of tour lines
- `--point-size`: Size of points (default: 1.0)
- `--line-width`: Width of tour lines (default: 2.0)
- `--line-color`: Color of tour lines (default: black)

Run `python stippling.py --help` or `python visualize.py --help` for complete usage information.

## Key Optimizations Explained

### 1. Numba JIT Compilation
```python
@jit(nopython=True, parallel=True)
def compute_voronoi_labels_numba(points, h, w):
    # Compiled to native code, runs in parallel across CPU cores
    # Achieves 5-10x speedup over pure Python
```

### 2. Parallel Voronoi Computation
```python
# Parallel distance computation across all pixels
# Each CPU core processes a subset of image pixels
labels = np.empty((h, w), dtype=np.int32)
for i in prange(h):  # Parallel loop
    for j in prange(w):
        # Find closest stipple point
```

### 3. Batch Centroid Computation
```python
# Instead of: for each point, compute centroid
# Do: compute all centroids simultaneously in parallel
centroids = compute_centroids_batch_numba(labels, rho, n_points)
```

### 4. Automatic Fallback
The implementation automatically falls back to pure Python if Numba is not available, ensuring compatibility across all systems while maintaining optimal performance when possible.

## References

- [TSP Art by Robert Bosch](https://www2.oberlin.edu/math/faculty/bosch/tspart-page.html)
- Secord, A. (2002). "Weighted Voronoi stippling"
- Lloyd, S. (1982). "Least squares quantization in PCM"
- Numba Documentation: https://numba.pydata.org/

## TSP (Traveling Salesman Problem) Integration

The stippling algorithm automatically generates TSP files containing the stipple coordinates. These can be used with external TSP solvers to optimize the drawing order for artistic and practical applications.

### Why Use TSP Optimization?

1. **Optimize stipple drawing order** - Minimize pen travel distance
2. **Efficient plotting paths** - Reduce drawing time for physical plotters
3. **Artistic line art** - Create beautiful continuous line drawings
4. **CNC machine paths** - Optimize tool paths for automated drawing

### TSP Workflow Overview

```
Image → stippling.py → .tsp file → TSP Solver → .tour file → visualize.py
```

1. **Generate TSP coordinates**: `stippling.py` creates `.tsp` files with stipple positions
2. **Solve TSP**: Use external solver (Concorde, Lin-Kernighan, etc.) to find optimal tour
3. **Visualize results**: `visualize.py` shows the optimized drawing path

### Getting TSP Solvers

#### Concorde TSP Solver (Exact, Optimal Solutions)
```bash
# Ubuntu/Debian
sudo apt-get install concorde-tsp

# macOS (with Homebrew)
brew install concorde

# From source
wget http://www.math.uwaterloo.ca/tsp/concorde/downloads/codes/src/co031219.tgz
# Follow compilation instructions
```

#### Lin-Kernighan Heuristic (Fast, Near-Optimal)
Usually included with Concorde package, or available separately:
```bash
# Often available as 'linkern' command after installing Concorde
linkern your_file.tsp
```

#### Online TSP Solvers
- [NEOS Server](https://neos-server.org/neos/) - Free online optimization
- [University of Waterloo TSP](http://www.math.uwaterloo.ca/tsp/) - Research tools
- Various academic TSP solver websites

### TSP File Format

The generated `.tsp` files follow the standard TSPLIB format:
```
NAME: EXAMPLE-512PX_5000
TYPE: TSP
COMMENT: Stipple points for Traveling Salesman Problem
DIMENSION: 5000
EDGE_WEIGHT_TYPE: EUC_2D
NODE_COORD_SECTION
1 245.123456 167.891234
2 312.456789 298.765432
...
EOF
```

### Tour File Format (.tour)

TSP solvers typically output tour files in this format:
```
5000 5000
0 2094 13
2094 7591 13
7591 7653 12
...
```

**Note:** Different TSP solvers may output different formats. The `visualize.py` script currently supports the Lin-Kernighan tour format. You may need to convert other formats.

### Using TSP Files

**Analyze a TSP instance:**
```bash
python tsp_utils.py stipplings/tsp/stipples.tsp --analyze
```

**Visualize stipple points:**
```bash
python tsp_utils.py stipplings/tsp/stipples.tsp --visualize --output tour_viz.png
```

**Generate a simple tour with nearest neighbor:**
```bash
python tsp_utils.py stipplings/tsp/stipples.tsp --nearest-neighbor --visualize
```

**Export for professional TSP solvers (e.g., Concorde):**
```bash
python tsp_utils.py stipplings/tsp/stipples.tsp --export-concorde
```

### Professional TSP Solvers

For optimal results with large stipple sets, consider:

1. **Concorde TSP Solver**: Industry-standard exact TSP solver
   ```bash
   # After exporting with tsp_utils.py
   concorde example-512px_5000_concorde.tsp
   ```

2. **Lin-Kernighan Solver within Concorde package**: Fast heuristic for large instances
   ```bash
   linkern example-512px_5000_concorde.tsp
   ```

## Workflow and File Organization

### Folder Structure

The project uses an organized folder structure to clearly separate different types of outputs:

```
weighted-voronoi-stippling/
├── images/              # Input images (source photos)
├── stipplings/          # Stippling algorithm outputs
│   ├── png/            # Generated stipple images (.png)
│   └── tsp/            # TSP problem files (.tsp)
├── visualizations/      # Tour visualization outputs
│   ├── tour/           # TSP solution files (.tour)
│   └── png/            # Tour visualization images (.png)
├── stippling.py         # Main stippling algorithm
├── visualize.py         # Tour visualization
└── tsp_utils.py         # TSP analysis utilities
```

### Complete Workflow

1. **Generate stipples and TSP file:**
   ```bash
   python stippling.py images/example-512px.png --stipples 5000 --iter 30
   # Creates: stipplings/png/example-512px_5000.png
   #          stipplings/tsp/example-512px_5000.tsp
   ```

2. **Solve TSP with external solver (e.g., Lin-Kernighan):**
   ```bash
   # In your TSP solver repository:
   linkern stipplings/tsp/example-512px_5000.tsp
   # Creates: example-512px_5000.tour
   ```

3. **Move tour file to visualizations folder:**
   ```bash
   mv example-512px_5000.tour visualizations/tour/
   ```

4. **Visualize the optimized tour:**
   ```bash
   python visualize.py --tsp-path stipplings/tsp/example-512px_5000.tsp \
                       --tour-path visualizations/tour/example-512px_5000.tour \
                       --output visualizations/png/example_tour_5000.png
   ```

### File Naming Convention

Files follow a consistent naming pattern that includes the stipple count:
- Input: `images/example-512px.png`
- Stipples: `stipplings/png/example-512px_5000.png` (includes stipple count)
- TSP: `stipplings/tsp/example-512px_5000.tsp` (includes stipple count)
- Tour: `visualizations/tour/example-512px_5000.tour` (matches TSP file)
- Visualization: `visualizations/png/example_tour_visualization.png`

The stipple count is automatically included in the output filenames to help distinguish between different stipple densities of the same input image.
